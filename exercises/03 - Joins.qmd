---
title: "Joins"
format: html
editor: visual
editor_options: 
  chunk_output_type: inline
---

## Introduction

Run the setup chunk below to load the packages we need for the session.

```{r setup}
library(tidyverse)
library(DBI)
library(RSQLite)
library(connections)
library(fuzzyjoin)
```

Connect to the MIMIC IV database

```{r connect}
mimic <- dbConnect(drv = RSQLite::SQLite(), 
                 dbname = "../mimic4.db")

connection_view(mimic)  # Necessary to view SQLite database tables in the Connections pane
```

Establish connection tables needed for the session.

```{r con_tables}
labevents <- tbl(mimic, "LABEVENTS")
d_labitems <- tbl(mimic, "D_LABITEMS")
patients <- tbl(mimic, "PATIENTS")
diagnoses_icd <- tbl(mimic,"DIAGNOSES_ICD")
admissions <- tbl(mimic, "ADMISSIONS")
```

#### Exercise 1a:

CAP is inspecting your lab and the lead inspectors asked your chair what your top performed test is.

Your chair surreptitiously texts you as he distracts the inspector with some free Nespresso……

Connect to the MIMIC IV database and answer:

**What the most commonly ordered lab test is in the database?**

*HINT: Analytic Strategy:*

1.  *Connect to the LABEVENTS table*
2.  *Count the number of rows per itemid*
3.  *Arrange from large to smallest count*
4.  *Top row is the winner!*

```{r exercise_1a}
## Create a pipe that starts from labevents database table and determines which itemid was ordered most frequently (This exercise reviews an exercise from Session 2)
labevents |>

  
```

### Exercise 1b:

Based on the above you should have identified the lab order associated with itemid 50971 as the most frequently ordered test.

But what is that lab test?

You can determine this using the tools you already know.

1.  Find 50971 in the View pane for D_LABITEMS

2.  Connect to D_LABITEMS and use `filter` to 50971.

Use one of the strategies above to determine what the most frequently ordered lab test is.

**But what if you needed to know what the *top 100* test orders were?**

## Joins

Joins are a mechanism to merge together related data residing in two different tables. In our example the `labevents` table and the `d_labitems` tables are related. The former contains information about each lab order placed in the EHR. the `d_labitems` table has metadata about each of the kinds of lab orders that can be placed in the EMR.

On a more concrete level, the `itemid` columns in both tables hold matching values, which means that an `itemid` in one table signifies the same lab order type as the same `itemid` in the other table.

There are several types of joins. In this workshop we will only review two.

### Inner Join

An inner join:

-   Retains only rows that match in both tables.
-   Excludes rows without matches in both tables.
-   Combines columns from both tables.

A prototypical left_join() function in R is structured like this:

```{r inner_join_template}
left_join(df1,df2,join_by(shared_column))
```

We can use this function to bring in the information from `d_labitems` that relates to the lab orders in order to decode the `itemid`'s.

```{r inner_join_example}
inner_join(labevents,d_labitems,join_by(itemid))

# OR

labevents |>
  inner_join(d_labitems,join_by(itemid))
```

### Exercise 2

Starting with `labevents` table, join to the `d_labitems` table using `inner_join`. Assign the result of your functions to `labevents_n`.

Find the number of times each lab order was placed

```{r exercise_2a}
labevents_n <- labevents |>

```

Follow-up questions:

-   Examine the original labevents table:
    -   How many distinct itemid's (test order types) does it have?
-   Examine the labevents_n table you produced:
    -   How many distinct itemid's (test order types) does it have?

```{r exercise_2b}
labevents |>
  
labevents_n |>

```

### Left Join

A left join:

-   Retains every row from the left table.
-   Includes only matching rows from the right table.
-   Combines columns from both tables.

```{r left_join_example}
labevents |>
  left_join(d_labitems,join_by(itemid))
```

### Exercise 3

Only one patient had a bleeding time (itemid 51149).

Using a left join find this patients gender and age by filtering the LABEVENTS table and joining to the PATIENTS table.

```{r exercise_3}
labevents |>
  
```

## Cartesian Products

### Exercise 4

You, the hematology laboratory director, are listening in on Hematology Grand Rounds while quietly shopping on Amazon.

During a discussion about thrombotic thrombocytopenic purpura, the Hematology Division Chief asks you if you knew what final diagnoses patients with schistocytes on their blood smear tend to have…

Using the following analytic strategy create a table containing the ICD codes associated with patients with schistocytes.

Analytic Strategy:

1.  Connect to `labevents`, `d_labitems`, `diagnoses_icd` tables
2.  Inner Join `labevents` to the `d_labitems` table
3.  Filter to patients positive for "Schistocytes"
    i.  HINT: The Schistocytes component is only reported when schistocytes are present.
4.  Join to `diagnoses_icd` table

```{r exercise_4}
labevents |>

```

Follow-up questions:

-   Examine your resulting table:
    -   How many rows does it have?
    -   Is this expected?
-   Can a patient have multiple Schistocyte results?
    -   Can a patient have multiple diagnostic codes?
    
When joining tables in which each row of each table can join to multiple rows of the other table based on the shared column, a so-called many to many relationship, you will end up with row duplication.

If you have time: How would you change the analytic strategy to correctly answer the question?

```{r exercise_4b}
labevents |>
  
  
```

## What Else?

Join using multiple columns

```{r multiplecols}
admissions %>%
  inner_join(labevents, by = c("subject_id", "hadm_id")) 
```

Join a table on itself

```{r}
labevents %>%
  rename(event1_charttime = charttime, event1_value = value) %>%
  inner_join(labevents %>% rename(event2_charttime = charttime, event2_value = value), 
             by = c("subject_id", "itemid")) %>%
  filter(event1_charttime < event2_charttime) %>%
  mutate(delta_value = event2_value - event1_value) %>%
  select(subject_id, itemid, event1_charttime, event1_value, event2_charttime, event2_value, delta_value)
```

Semi_join

```{r}
labevents %>%
  filter(itemid == 51287) %>%
  semi_join(labevents,., join_by(subject_id))
```

Non-equi joins

```{r}

```

Fuzzyjoin

```{r fuzzyjoin}

# Access tables
diagnoses_icd9 <-
  tbl(mimic, "d_icd_diagnoses") |> 
  filter(icd_version == 9) |> 
  collect() |> 
  sample_n(2000)
diagnoses_icd10 <-
  tbl(mimic, "d_icd_diagnoses") |> 
  filter(icd_version == 10) |> 
  collect() |> 
  sample_n(2000)


# Perform a fuzzy join using string distance on descriptions
result <- diagnoses_icd9 %>%
  stringdist_inner_join(diagnoses_icd10, by = c("long_title" = "long_title"), method = "jw", max_dist = 0.1)

# Select relevant columns for the final result
result <- result |>
  select(icd9_code = icd_code.x, icd9_desc = long_title.x, icd10_code = icd_code.y, icd10_desc = long_title.y)

```
